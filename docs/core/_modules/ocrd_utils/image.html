<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ocrd_utils.image &#8212; ocrd 2.58.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b76e3c8a" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=c89f9379"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../../_static/ocrd-custom.js?v=285d69d9"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
    <link rel="canonical" href="https://ocr-d.de_modules/ocrd_utils/image.html"/>
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for ocrd_utils.image</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">sys</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span><span class="p">,</span> <span class="n">ImageStat</span><span class="p">,</span> <span class="n">ImageDraw</span><span class="p">,</span> <span class="n">ImageChops</span>

<span class="kn">from</span> <span class="nn">.logging</span> <span class="kn">import</span> <span class="n">getLogger</span>
<span class="kn">from</span> <span class="nn">.introspect</span> <span class="kn">import</span> <span class="n">membername</span>

<span class="c1"># Allow processing of images with up to 1.6bn pixels</span>
<span class="c1"># https://github.com/OCR-D/core/issues/735</span>
<span class="n">Image</span><span class="o">.</span><span class="n">MAX_IMAGE_PIXELS</span> <span class="o">=</span> <span class="mi">40_000</span> <span class="o">**</span> <span class="mi">2</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;adjust_canvas_to_rotation&#39;</span><span class="p">,</span>
    <span class="s1">&#39;adjust_canvas_to_transposition&#39;</span><span class="p">,</span>
    <span class="s1">&#39;bbox_from_points&#39;</span><span class="p">,</span>
    <span class="s1">&#39;bbox_from_polygon&#39;</span><span class="p">,</span>
    <span class="s1">&#39;bbox_from_xywh&#39;</span><span class="p">,</span>
    <span class="s1">&#39;coordinates_for_segment&#39;</span><span class="p">,</span>
    <span class="s1">&#39;coordinates_of_segment&#39;</span><span class="p">,</span>
    <span class="s1">&#39;image_from_polygon&#39;</span><span class="p">,</span>
    <span class="s1">&#39;points_from_bbox&#39;</span><span class="p">,</span>
    <span class="s1">&#39;points_from_polygon&#39;</span><span class="p">,</span>
    <span class="s1">&#39;points_from_x0y0x1y1&#39;</span><span class="p">,</span>
    <span class="s1">&#39;points_from_xywh&#39;</span><span class="p">,</span>
    <span class="s1">&#39;points_from_y0x0y1x1&#39;</span><span class="p">,</span>
    <span class="s1">&#39;polygon_from_bbox&#39;</span><span class="p">,</span>
    <span class="s1">&#39;polygon_from_points&#39;</span><span class="p">,</span>
    <span class="s1">&#39;polygon_from_x0y0x1y1&#39;</span><span class="p">,</span>
    <span class="s1">&#39;polygon_from_xywh&#39;</span><span class="p">,</span>
    <span class="s1">&#39;polygon_mask&#39;</span><span class="p">,</span>
    <span class="s1">&#39;rotate_coordinates&#39;</span><span class="p">,</span>
    <span class="s1">&#39;shift_coordinates&#39;</span><span class="p">,</span>
    <span class="s1">&#39;scale_coordinates&#39;</span><span class="p">,</span>
    <span class="s1">&#39;transform_coordinates&#39;</span><span class="p">,</span>
    <span class="s1">&#39;transpose_coordinates&#39;</span><span class="p">,</span>
    <span class="s1">&#39;xywh_from_bbox&#39;</span><span class="p">,</span>
    <span class="s1">&#39;xywh_from_points&#39;</span><span class="p">,</span>
    <span class="s1">&#39;xywh_from_polygon&#39;</span><span class="p">,</span>
<span class="p">]</span>

<div class="viewcode-block" id="adjust_canvas_to_rotation"><a class="viewcode-back" href="../../api/ocrd_utils/ocrd_utils.image.html#ocrd_utils.image.adjust_canvas_to_rotation">[docs]</a><span class="k">def</span> <span class="nf">adjust_canvas_to_rotation</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">angle</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the enlarged image size after rotation.</span>
<span class="sd">    </span>
<span class="sd">    Given a numpy array ``size`` of an original canvas (width and height),</span>
<span class="sd">    and a rotation angle in degrees counter-clockwise ``angle``,</span>
<span class="sd">    calculate the new size which is necessary to encompass the full</span>
<span class="sd">    image after rotation.</span>
<span class="sd">    </span>
<span class="sd">    Return a numpy array of the enlarged width and height.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
    <span class="n">sin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">))</span>
    <span class="n">cos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">cos</span><span class="p">,</span> <span class="n">sin</span><span class="p">],</span>
                            <span class="p">[</span><span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">]]),</span>
                  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">size</span><span class="p">))</span></div>

<div class="viewcode-block" id="adjust_canvas_to_transposition"><a class="viewcode-back" href="../../api/ocrd_utils/ocrd_utils.image.html#ocrd_utils.image.adjust_canvas_to_transposition">[docs]</a><span class="k">def</span> <span class="nf">adjust_canvas_to_transposition</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the flipped image size after transposition.</span>
<span class="sd">    </span>
<span class="sd">    Given a numpy array ``size`` of an original canvas (width and height),</span>
<span class="sd">    and a transposition mode ``method`` (see ``transpose_image``),</span>
<span class="sd">    calculate the new size after transposition.</span>
<span class="sd">    </span>
<span class="sd">    Return a numpy array of the enlarged width and height.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="n">Image</span><span class="o">.</span><span class="n">ROTATE_90</span><span class="p">,</span>
                  <span class="n">Image</span><span class="o">.</span><span class="n">ROTATE_270</span><span class="p">,</span>
                  <span class="n">Image</span><span class="o">.</span><span class="n">TRANSPOSE</span><span class="p">,</span>
                  <span class="n">Image</span><span class="o">.</span><span class="n">TRANSVERSE</span><span class="p">]:</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">size</span></div>

<div class="viewcode-block" id="bbox_from_points"><a class="viewcode-back" href="../../api/ocrd_utils/ocrd_utils.image.html#ocrd_utils.image.bbox_from_points">[docs]</a><span class="k">def</span> <span class="nf">bbox_from_points</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Construct a numeric list representing a bounding box from polygon coordinates in page representation.&quot;&quot;&quot;</span>
    <span class="n">xys</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">int</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pair</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)]</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">points</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">bbox_from_polygon</span><span class="p">(</span><span class="n">xys</span><span class="p">)</span></div>

<div class="viewcode-block" id="bbox_from_polygon"><a class="viewcode-back" href="../../api/ocrd_utils/ocrd_utils.image.html#ocrd_utils.image.bbox_from_polygon">[docs]</a><span class="k">def</span> <span class="nf">bbox_from_polygon</span><span class="p">(</span><span class="n">polygon</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Construct a numeric list representing a bounding box from polygon coordinates in numeric list representation.&quot;&quot;&quot;</span>
    <span class="n">minx</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span>
    <span class="n">miny</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span>
    <span class="n">maxx</span> <span class="o">=</span> <span class="o">-</span><span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span>
    <span class="n">maxy</span> <span class="o">=</span> <span class="o">-</span><span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span>
    <span class="k">for</span> <span class="n">xy</span> <span class="ow">in</span> <span class="n">polygon</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">minx</span><span class="p">:</span>
            <span class="n">minx</span> <span class="o">=</span> <span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">maxx</span><span class="p">:</span>
            <span class="n">maxx</span> <span class="o">=</span> <span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">miny</span><span class="p">:</span>
            <span class="n">miny</span> <span class="o">=</span> <span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">maxy</span><span class="p">:</span>
            <span class="n">maxy</span> <span class="o">=</span> <span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span></div>

<div class="viewcode-block" id="bbox_from_xywh"><a class="viewcode-back" href="../../api/ocrd_utils/ocrd_utils.image.html#ocrd_utils.image.bbox_from_xywh">[docs]</a><span class="k">def</span> <span class="nf">bbox_from_xywh</span><span class="p">(</span><span class="n">xywh</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert a bounding box from a numeric dict to a numeric list representation.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">xywh</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">],</span>
        <span class="n">xywh</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">],</span>
        <span class="n">xywh</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">xywh</span><span class="p">[</span><span class="s1">&#39;w&#39;</span><span class="p">],</span>
        <span class="n">xywh</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">xywh</span><span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">]</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="coordinates_of_segment"><a class="viewcode-back" href="../../api/ocrd_utils/ocrd_utils.image.html#ocrd_utils.image.coordinates_of_segment">[docs]</a><span class="k">def</span> <span class="nf">coordinates_of_segment</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="n">parent_image</span><span class="p">,</span> <span class="n">parent_coords</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extract the coordinates of a PAGE segment element relative to its parent.</span>

<span class="sd">    Given...</span>

<span class="sd">    - ``segment``, a PAGE segment object in absolute coordinates</span>
<span class="sd">      (i.e. RegionType / TextLineType / WordType / GlyphType), and</span>
<span class="sd">    - ``parent_image``, the PIL.Image of its corresponding parent object</span>
<span class="sd">      (i.e. PageType / RegionType / TextLineType / WordType), (not used),</span>
<span class="sd">      along with</span>
<span class="sd">    - ``parent_coords``, its corresponding affine transformation,</span>

<span class="sd">    ...calculate the relative coordinates of the segment within the image.</span>

<span class="sd">    That is, apply the given transform to the points annotated in ``segment``.</span>
<span class="sd">    The transform encodes (recursively):</span>

<span class="sd">    1. Whenever ``parent_image`` or any of its parents was cropped,</span>
<span class="sd">       all points must be shifted by the offset</span>
<span class="sd">       (i.e. coordinate system gets translated by the upper left).</span>
<span class="sd">    2. Whenever ``parent_image`` or any of its parents was rotated,</span>
<span class="sd">       all points must be rotated around the center of that image</span>
<span class="sd">       (i.e. coordinate system gets translated by the center in</span>
<span class="sd">       opposite direction, rotated purely, and translated back;</span>
<span class="sd">       the latter involves an additional offset from the increase</span>
<span class="sd">       in canvas size necessary to accommodate all points).</span>

<span class="sd">    Return the rounded numpy array of the resulting polygon.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># get polygon:</span>
    <span class="n">polygon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">polygon_from_points</span><span class="p">(</span><span class="n">segment</span><span class="o">.</span><span class="n">get_Coords</span><span class="p">()</span><span class="o">.</span><span class="n">points</span><span class="p">))</span>
    <span class="c1"># apply affine transform:</span>
    <span class="n">polygon</span> <span class="o">=</span> <span class="n">transform_coordinates</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="n">parent_coords</span><span class="p">[</span><span class="s1">&#39;transform&#39;</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">polygon</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span></div>

<div class="viewcode-block" id="polygon_from_points"><a class="viewcode-back" href="../../api/ocrd_utils/ocrd_utils.image.html#ocrd_utils.image.polygon_from_points">[docs]</a><span class="k">def</span> <span class="nf">polygon_from_points</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert polygon coordinates in page representation to polygon coordinates in numeric list representation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">polygon</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">points</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">):</span>
        <span class="n">x_y</span> <span class="o">=</span> <span class="n">pair</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
        <span class="n">polygon</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">x_y</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">x_y</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span>
    <span class="k">return</span> <span class="n">polygon</span></div>


<div class="viewcode-block" id="coordinates_for_segment"><a class="viewcode-back" href="../../api/ocrd_utils/ocrd_utils.image.html#ocrd_utils.image.coordinates_for_segment">[docs]</a><span class="k">def</span> <span class="nf">coordinates_for_segment</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="n">parent_image</span><span class="p">,</span> <span class="n">parent_coords</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert relative coordinates to absolute.</span>

<span class="sd">    Given...</span>

<span class="sd">    - ``polygon``, a numpy array of points relative to</span>
<span class="sd">    - ``parent_image``, a PIL.Image (not used), along with</span>
<span class="sd">    - ``parent_coords``, its corresponding affine transformation,</span>

<span class="sd">    ...calculate the absolute coordinates within the page.</span>
<span class="sd">    </span>
<span class="sd">    That is, apply the given transform inversely to ``polygon``</span>
<span class="sd">    The transform encodes (recursively):</span>

<span class="sd">    1. Whenever ``parent_image`` or any of its parents was cropped,</span>
<span class="sd">       all points must be shifted by the offset in opposite direction</span>
<span class="sd">       (i.e. coordinate system gets translated by the upper left).</span>
<span class="sd">    2. Whenever ``parent_image`` or any of its parents was rotated,</span>
<span class="sd">       all points must be rotated around the center of that image in</span>
<span class="sd">       opposite direction</span>
<span class="sd">       (i.e. coordinate system gets translated by the center in</span>
<span class="sd">       opposite direction, rotated purely, and translated back;</span>
<span class="sd">       the latter involves an additional offset from the increase</span>
<span class="sd">       in canvas size necessary to accommodate all points).</span>

<span class="sd">    Return the rounded numpy array of the resulting polygon.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">polygon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="c1"># avoid implicit type cast problems</span>
    <span class="c1"># apply inverse of affine transform:</span>
    <span class="n">inv_transform</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">parent_coords</span><span class="p">[</span><span class="s1">&#39;transform&#39;</span><span class="p">])</span>
    <span class="n">polygon</span> <span class="o">=</span> <span class="n">transform_coordinates</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="n">inv_transform</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">polygon</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span></div>

<div class="viewcode-block" id="polygon_mask"><a class="viewcode-back" href="../../api/ocrd_utils/ocrd_utils.image.html#ocrd_utils.image.polygon_mask">[docs]</a><span class="k">def</span> <span class="nf">polygon_mask</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;&quot;Create a mask image of a polygon.</span>

<span class="sd">    Given a PIL.Image ``image`` (merely for dimensions), and</span>
<span class="sd">    a numpy array ``polygon`` of relative coordinates into the image,</span>
<span class="sd">    create a new image of the same size with black background, and</span>
<span class="sd">    fill everything inside the polygon hull with white.</span>

<span class="sd">    Return the new PIL.Image.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">&#39;L&#39;</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">coordinates</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">))</span>
    <span class="n">ImageDraw</span><span class="o">.</span><span class="n">Draw</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">outline</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="mi">255</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mask</span></div>

<div class="viewcode-block" id="rotate_coordinates"><a class="viewcode-back" href="../../api/ocrd_utils/ocrd_utils.image.html#ocrd_utils.image.rotate_coordinates">[docs]</a><span class="k">def</span> <span class="nf">rotate_coordinates</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">orig</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compose an affine coordinate transformation with a passive rotation.</span>

<span class="sd">    Given a numpy array ``transform`` of an existing transformation</span>
<span class="sd">    matrix in homogeneous (3d) coordinates, and a rotation angle in</span>
<span class="sd">    degrees counter-clockwise ``angle``, as well as a numpy array</span>
<span class="sd">    ``orig`` of the center of rotation, calculate the affine</span>
<span class="sd">    coordinate transform corresponding to the composition of both</span>
<span class="sd">    transformations. (This entails translation to the center, followed</span>
<span class="sd">    by pure rotation, and subsequent translation back. However, since</span>
<span class="sd">    rotation necessarily increases the bounding box, and thus image size,</span>
<span class="sd">    do not translate back the same amount, but to the enlarged offset.)</span>
<span class="sd">    </span>
<span class="sd">    Return a numpy array of the resulting affine transformation matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">LOG</span> <span class="o">=</span> <span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;ocrd.utils.coords.rotate_coordinates&#39;</span><span class="p">)</span>
    <span class="n">rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
    <span class="n">cos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">rad</span><span class="p">)</span>
    <span class="n">sin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">rad</span><span class="p">)</span>
    <span class="c1"># get rotation matrix for passive rotation:</span>
    <span class="n">rot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">+</span><span class="n">cos</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                    <span class="p">[</span><span class="o">-</span><span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
    <span class="c1"># shift to center of rotation</span>
    <span class="n">transform</span> <span class="o">=</span> <span class="n">shift_coordinates</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="o">-</span><span class="n">orig</span><span class="p">)</span>
    <span class="c1"># apply pure rotation</span>
    <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;rotating coordinates by </span><span class="si">%.2f</span><span class="s1">° around </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">orig</span><span class="p">))</span>
    <span class="n">transform</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rot</span><span class="p">,</span> <span class="n">transform</span><span class="p">)</span>
    <span class="c1"># shift back</span>
    <span class="n">transform</span> <span class="o">=</span> <span class="n">shift_coordinates</span><span class="p">(</span>
        <span class="n">transform</span><span class="p">,</span>
        <span class="c1">#orig)</span>
        <span class="c1"># the image (bounding box) increases with rotation,</span>
        <span class="c1"># so we must translate back to the new upper left:</span>
        <span class="n">adjust_canvas_to_rotation</span><span class="p">(</span><span class="n">orig</span><span class="p">,</span> <span class="n">angle</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">transform</span></div>

<span class="k">def</span> <span class="nf">rotate_image</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="s1">&#39;background&#39;</span><span class="p">,</span> <span class="n">transparency</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;&quot;Rotate an image, enlarging and filling with background.</span>

<span class="sd">    Given a PIL.Image ``image`` and a rotation angle in degrees</span>
<span class="sd">    counter-clockwise ``angle``, rotate the image, increasing its</span>
<span class="sd">    size at the margins accordingly, and filling everything outside</span>
<span class="sd">    the original image according to ``fill``:</span>

<span class="sd">    - if ``background`` (the default),</span>
<span class="sd">      then use the median color of the image;</span>
<span class="sd">    - otherwise use the given color, e.g. ``&#39;white&#39;`` or (255,255,255).</span>

<span class="sd">    Moreover, if ``transparency`` is true, then add an alpha channel</span>
<span class="sd">    fully opaque (i.e. everything outside the original image will</span>
<span class="sd">    be transparent for those that can interpret alpha channels).</span>
<span class="sd">    (This is true for images which already have an alpha channel,</span>
<span class="sd">    regardless of the setting used.)</span>

<span class="sd">    Return a new PIL.Image.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">LOG</span> <span class="o">=</span> <span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;ocrd.utils.rotate_image&#39;</span><span class="p">)</span>
    <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;rotating image by </span><span class="si">%.2f</span><span class="s1">°&#39;</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">transparency</span> <span class="ow">and</span> <span class="n">image</span><span class="o">.</span><span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;RGB&#39;</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">]:</span>
        <span class="c1"># ensure no information is lost by adding transparency channel</span>
        <span class="c1"># initialized to fully opaque (so cropping and rotation will</span>
        <span class="c1"># expose areas as transparent):</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">image</span><span class="o">.</span><span class="n">putalpha</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">fill</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">fill</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;background&#39;</span><span class="p">,</span> <span class="s1">&#39;none&#39;</span><span class="p">]:</span>
        <span class="n">background</span> <span class="o">=</span> <span class="n">ImageStat</span><span class="o">.</span><span class="n">Stat</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">background</span><span class="o">.</span><span class="n">bands</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">background</span> <span class="o">=</span> <span class="n">background</span><span class="o">.</span><span class="n">median</span>
            <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;RGBA&#39;</span><span class="p">,</span> <span class="s1">&#39;LA&#39;</span><span class="p">]:</span>
                <span class="n">background</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># fully transparent</span>
            <span class="n">background</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">background</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">background</span> <span class="o">=</span> <span class="n">background</span><span class="o">.</span><span class="n">median</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">background</span> <span class="o">=</span> <span class="n">fill</span>
    <span class="n">new_image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span>
                             <span class="n">expand</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                             <span class="c1">#resample=Image.BILINEAR,</span>
                             <span class="n">fillcolor</span><span class="o">=</span><span class="n">background</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">new_image</span><span class="o">.</span><span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;LA&#39;</span><span class="p">]:</span>
        <span class="c1"># workaround for #1600 (bug in LA support which</span>
        <span class="c1"># causes areas fully transparent before rotation</span>
        <span class="c1"># to be filled with black here):</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">new_image</span>
        <span class="n">new_image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">mode</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">background</span><span class="p">)</span>
        <span class="n">new_image</span><span class="o">.</span><span class="n">paste</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">getchannel</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">new_image</span>


<div class="viewcode-block" id="shift_coordinates"><a class="viewcode-back" href="../../api/ocrd_utils/ocrd_utils.image.html#ocrd_utils.image.shift_coordinates">[docs]</a><span class="k">def</span> <span class="nf">shift_coordinates</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compose an affine coordinate transformation with a translation.</span>

<span class="sd">    Given a numpy array ``transform`` of an existing transformation</span>
<span class="sd">    matrix in homogeneous (3d) coordinates, and a numpy array</span>
<span class="sd">    ``offset`` of the translation vector, calculate the affine</span>
<span class="sd">    coordinate transform corresponding to the composition of both</span>
<span class="sd">    transformations.</span>
<span class="sd">    </span>
<span class="sd">    Return a numpy array of the resulting affine transformation matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">LOG</span> <span class="o">=</span> <span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;ocrd.utils.coords.shift_coordinates&#39;</span><span class="p">)</span>
    <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;shifting coordinates by </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">offset</span><span class="p">))</span>
    <span class="n">shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">shift</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">offset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">shift</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">offset</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">shift</span><span class="p">,</span> <span class="n">transform</span><span class="p">)</span></div>

<div class="viewcode-block" id="scale_coordinates"><a class="viewcode-back" href="../../api/ocrd_utils/ocrd_utils.image.html#ocrd_utils.image.scale_coordinates">[docs]</a><span class="k">def</span> <span class="nf">scale_coordinates</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">factors</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compose an affine coordinate transformation with a proportional scaling.</span>
<span class="sd">    Given a numpy array ``transform`` of an existing transformation</span>
<span class="sd">    matrix in homogeneous (3d) coordinates, and a numpy array</span>
<span class="sd">    ``factors`` of the scaling factors, calculate the affine</span>
<span class="sd">    coordinate transform corresponding to the composition of both</span>
<span class="sd">    transformations.</span>
<span class="sd">    </span>
<span class="sd">    Return a numpy array of the resulting affine transformation matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">LOG</span> <span class="o">=</span> <span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;ocrd.utils.coords.scale_coordinates&#39;</span><span class="p">)</span>
    <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;scaling coordinates by </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">factors</span><span class="p">))</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">scale</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">factors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">scale</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">factors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">transform</span><span class="p">)</span></div>

<div class="viewcode-block" id="transform_coordinates"><a class="viewcode-back" href="../../api/ocrd_utils/ocrd_utils.image.html#ocrd_utils.image.transform_coordinates">[docs]</a><span class="k">def</span> <span class="nf">transform_coordinates</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply an affine transformation to a set of points.</span>
<span class="sd">    Augment the 2d numpy array of points ``polygon`` with a an extra</span>
<span class="sd">    column of ones (homogeneous coordinates), then multiply with</span>
<span class="sd">    the transformation matrix ``transform`` (or the identity matrix),</span>
<span class="sd">    and finally remove the extra column from the result.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">transform</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">transform</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">polygon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># make 3d homogeneous coordinates</span>
    <span class="n">polygon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">polygon</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="c1"># ones = polygon[:,2]</span>
    <span class="c1"># assert np.all(np.array_equal(ones, np.clip(ones, 1 - 1e-2, 1 + 1e-2))), \</span>
    <span class="c1">#     &#39;affine transform failed&#39; # should never happen</span>
    <span class="n">polygon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># remove z coordinate again</span>
    <span class="k">return</span> <span class="n">polygon</span></div>

<div class="viewcode-block" id="transpose_coordinates"><a class="viewcode-back" href="../../api/ocrd_utils/ocrd_utils.image.html#ocrd_utils.image.transpose_coordinates">[docs]</a><span class="k">def</span> <span class="nf">transpose_coordinates</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">orig</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;&quot;Compose an affine coordinate transformation with a transposition (i.e. flip or rotate in 90° multiples).</span>

<span class="sd">    Given a numpy array ``transform`` of an existing transformation</span>
<span class="sd">    matrix in homogeneous (3d) coordinates, a transposition mode ``method``,</span>
<span class="sd">    as well as a numpy array ``orig`` of the center of the image,</span>
<span class="sd">    calculate the affine coordinate transform corresponding to the composition</span>
<span class="sd">    of both transformations, which is respectively:</span>

<span class="sd">    - ``PIL.Image.FLIP_LEFT_RIGHT``:</span>
<span class="sd">      entails translation to the center, followed by pure reflection</span>
<span class="sd">      about the y-axis, and subsequent translation back</span>
<span class="sd">    - ``PIL.Image.FLIP_TOP_BOTTOM``:</span>
<span class="sd">      entails translation to the center, followed by pure reflection</span>
<span class="sd">      about the x-axis, and subsequent translation back</span>
<span class="sd">    - ``PIL.Image.ROTATE_180``:</span>
<span class="sd">      entails translation to the center, followed by pure reflection</span>
<span class="sd">      about the origin, and subsequent translation back</span>
<span class="sd">    - ``PIL.Image.ROTATE_90``:</span>
<span class="sd">      entails translation to the center, followed by pure rotation</span>
<span class="sd">      by 90° counter-clockwise, and subsequent translation back</span>
<span class="sd">    - ``PIL.Image.ROTATE_270``:</span>
<span class="sd">      entails translation to the center, followed by pure rotation</span>
<span class="sd">      by 270° counter-clockwise, and subsequent translation back</span>
<span class="sd">    - ``PIL.Image.TRANSPOSE``:</span>
<span class="sd">      entails translation to the center, followed by pure rotation</span>
<span class="sd">      by 90° counter-clockwise and pure reflection about the x-axis,</span>
<span class="sd">      and subsequent translation back</span>
<span class="sd">    - ``PIL.Image.TRANSVERSE``:</span>
<span class="sd">      entails translation to the center, followed by pure rotation</span>
<span class="sd">      by 90° counter-clockwise and pure reflection about the y-axis,</span>
<span class="sd">      and subsequent translation back</span>

<span class="sd">    Return a numpy array of the resulting affine transformation matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">LOG</span> <span class="o">=</span> <span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;ocrd.utils.coords.transpose_coordinates&#39;</span><span class="p">)</span>
    <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;transposing coordinates with </span><span class="si">%s</span><span class="s1"> around </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">membername</span><span class="p">(</span><span class="n">Image</span><span class="p">,</span> <span class="n">method</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">orig</span><span class="p">))</span>
    <span class="c1"># get rotation matrix for passive rotation/reflection:</span>
    <span class="n">rot90</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                      <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
    <span class="n">reflx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
    <span class="n">refly</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
    <span class="n">transform</span> <span class="o">=</span> <span class="n">shift_coordinates</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="o">-</span><span class="n">orig</span><span class="p">)</span>
    <span class="n">operations</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">Image</span><span class="o">.</span><span class="n">FLIP_LEFT_RIGHT</span><span class="p">:</span> <span class="p">[</span><span class="n">refly</span><span class="p">],</span>
        <span class="n">Image</span><span class="o">.</span><span class="n">FLIP_TOP_BOTTOM</span><span class="p">:</span> <span class="p">[</span><span class="n">reflx</span><span class="p">],</span>
        <span class="n">Image</span><span class="o">.</span><span class="n">ROTATE_180</span><span class="p">:</span> <span class="p">[</span><span class="n">reflx</span><span class="p">,</span> <span class="n">refly</span><span class="p">],</span>
        <span class="n">Image</span><span class="o">.</span><span class="n">ROTATE_90</span><span class="p">:</span> <span class="p">[</span><span class="n">rot90</span><span class="p">],</span>
        <span class="n">Image</span><span class="o">.</span><span class="n">ROTATE_270</span><span class="p">:</span> <span class="p">[</span><span class="n">rot90</span><span class="p">,</span> <span class="n">reflx</span><span class="p">,</span> <span class="n">refly</span><span class="p">],</span>
        <span class="n">Image</span><span class="o">.</span><span class="n">TRANSPOSE</span><span class="p">:</span> <span class="p">[</span><span class="n">rot90</span><span class="p">,</span> <span class="n">reflx</span><span class="p">],</span>
        <span class="n">Image</span><span class="o">.</span><span class="n">TRANSVERSE</span><span class="p">:</span> <span class="p">[</span><span class="n">rot90</span><span class="p">,</span> <span class="n">refly</span><span class="p">]</span>
    <span class="p">}</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">method</span><span class="p">)</span> <span class="c1"># no default</span>
    <span class="k">for</span> <span class="n">operation</span> <span class="ow">in</span> <span class="n">operations</span><span class="p">:</span>
        <span class="n">transform</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">operation</span><span class="p">,</span> <span class="n">transform</span><span class="p">)</span>
    <span class="n">transform</span> <span class="o">=</span> <span class="n">shift_coordinates</span><span class="p">(</span>
        <span class="n">transform</span><span class="p">,</span>
        <span class="c1"># the image (bounding box) may flip with transposition,</span>
        <span class="c1"># so we must translate back to the new upper left:</span>
        <span class="n">adjust_canvas_to_transposition</span><span class="p">(</span><span class="n">orig</span><span class="p">,</span> <span class="n">method</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">transform</span></div>

<span class="k">def</span> <span class="nf">transpose_image</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;&quot;Transpose (i.e. flip or rotate in 90° multiples) an image.</span>

<span class="sd">    Given a PIL.Image ``image`` and a transposition mode ``method``,</span>
<span class="sd">    apply the respective operation:</span>

<span class="sd">    - ``PIL.Image.FLIP_LEFT_RIGHT``:</span>
<span class="sd">      all pixels get mirrored at half the width of the image</span>
<span class="sd">    - ``PIL.Image.FLIP_TOP_BOTTOM``:</span>
<span class="sd">      all pixels get mirrored at half the height of the image</span>
<span class="sd">    - ``PIL.Image.ROTATE_180``:</span>
<span class="sd">      all pixels get mirrored at both, the width and half the height</span>
<span class="sd">      of the image,</span>
<span class="sd">      i.e. the image gets rotated by 180° counter-clockwise</span>
<span class="sd">    - ``PIL.Image.ROTATE_90``:</span>
<span class="sd">      rows become columns (but counted from the right) and</span>
<span class="sd">      columns become rows,</span>
<span class="sd">      i.e. the image gets rotated by 90° counter-clockwise;</span>
<span class="sd">      width becomes height and vice versa</span>
<span class="sd">    - ``PIL.Image.ROTATE_270``:</span>
<span class="sd">      rows become columns and</span>
<span class="sd">      columns become rows (but counted from the bottom),</span>
<span class="sd">      i.e. the image gets rotated by 270° counter-clockwise;</span>
<span class="sd">      width becomes height and vice versa</span>
<span class="sd">    - ``PIL.Image.TRANSPOSE``:</span>
<span class="sd">      rows become columns and vice versa,</span>
<span class="sd">      i.e. all pixels get mirrored at the main diagonal;</span>
<span class="sd">      width becomes height and vice versa</span>
<span class="sd">    - ``PIL.Image.TRANSVERSE``:</span>
<span class="sd">      rows become columns (but counted from the right) and</span>
<span class="sd">      columns become rows (but counted from the bottom),</span>
<span class="sd">      i.e. all pixels get mirrored at the opposite diagonal;</span>
<span class="sd">      width becomes height and vice versa</span>
<span class="sd">    </span>
<span class="sd">    Return a new PIL.Image.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">LOG</span> <span class="o">=</span> <span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;ocrd.utils.transpose_image&#39;</span><span class="p">)</span>
    <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;transposing image with </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">membername</span><span class="p">(</span><span class="n">Image</span><span class="p">,</span> <span class="n">method</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">image</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">crop_image</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">box</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;&quot;Crop an image to a rectangle, filling with background.</span>

<span class="sd">    Given a PIL.Image ``image`` and a list ``box`` of the bounding</span>
<span class="sd">    rectangle relative to the image, crop at the box coordinates,</span>
<span class="sd">    filling everything outside ``image`` with the background.</span>
<span class="sd">    (This covers the case where ``box`` indexes are negative or</span>
<span class="sd">    larger than ``image`` width/height. PIL.Image.crop would fill</span>
<span class="sd">    with black.) Since ``image`` is not necessarily binarized yet,</span>
<span class="sd">    determine the background from the median color (instead of</span>
<span class="sd">    white).</span>

<span class="sd">    Return a new PIL.Image.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">LOG</span> <span class="o">=</span> <span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;ocrd.utils.crop_image&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">box</span><span class="p">:</span>
        <span class="n">box</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">height</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">box</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">box</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">box</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">image</span><span class="o">.</span><span class="n">width</span> <span class="ow">or</span> <span class="n">box</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">image</span><span class="o">.</span><span class="n">height</span><span class="p">:</span>
        <span class="c1"># (It should be invalid in PAGE-XML to extend beyond parents.)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;crop coordinates (</span><span class="si">%s</span><span class="s1">) exceed image (</span><span class="si">%d</span><span class="s1">x</span><span class="si">%d</span><span class="s1">)&#39;</span><span class="p">,</span>
                    <span class="nb">str</span><span class="p">(</span><span class="n">box</span><span class="p">),</span> <span class="n">image</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">height</span><span class="p">)</span>
    <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;cropping image to </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">box</span><span class="p">))</span>
    <span class="n">xywh</span> <span class="o">=</span> <span class="n">xywh_from_bbox</span><span class="p">(</span><span class="o">*</span><span class="n">box</span><span class="p">)</span>
    <span class="n">poly</span> <span class="o">=</span> <span class="n">polygon_from_bbox</span><span class="p">(</span><span class="o">*</span><span class="n">box</span><span class="p">)</span>
    <span class="n">background</span> <span class="o">=</span> <span class="n">ImageStat</span><span class="o">.</span><span class="n">Stat</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">polygon_mask</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">poly</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">background</span><span class="o">.</span><span class="n">bands</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">background</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">background</span><span class="o">.</span><span class="n">median</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">background</span> <span class="o">=</span> <span class="n">background</span><span class="o">.</span><span class="n">median</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">new_image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">mode</span><span class="p">,</span> <span class="p">(</span><span class="n">xywh</span><span class="p">[</span><span class="s1">&#39;w&#39;</span><span class="p">],</span> <span class="n">xywh</span><span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">]),</span>
                          <span class="n">background</span><span class="p">)</span> <span class="c1"># or &#39;white&#39;</span>
    <span class="n">new_image</span><span class="o">.</span><span class="n">paste</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">xywh</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="o">-</span><span class="n">xywh</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">new_image</span>

<div class="viewcode-block" id="image_from_polygon"><a class="viewcode-back" href="../../api/ocrd_utils/ocrd_utils.image.html#ocrd_utils.image.image_from_polygon">[docs]</a><span class="k">def</span> <span class="nf">image_from_polygon</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">polygon</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="s1">&#39;background&#39;</span><span class="p">,</span> <span class="n">transparency</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;&quot;Mask an image with a polygon.</span>

<span class="sd">    Given a PIL.Image ``image`` and a numpy array ``polygon``</span>
<span class="sd">    of relative coordinates into the image, fill everything</span>
<span class="sd">    outside the polygon hull to a color according to ``fill``:</span>

<span class="sd">    - if ``none`` then do not touch the colour channels at all,</span>
<span class="sd">    - else if ``background`` (the default),</span>
<span class="sd">      then use the median color of the image;</span>
<span class="sd">    - otherwise use the given color, e.g. ``&#39;white&#39;`` or (255,255,255).</span>

<span class="sd">    Moreover, if ``transparency`` is true, then add an alpha channel</span>
<span class="sd">    from the polygon mask (i.e. everything outside the polygon will</span>
<span class="sd">    be transparent, for those consumers that can interpret alpha channels).</span>
<span class="sd">    Images which already have an alpha channel will have it shrunk</span>
<span class="sd">    from the polygon mask (i.e. everything outside the polygon will</span>
<span class="sd">    be transparent, in addition to existing transparent pixels).</span>
<span class="sd">    </span>
<span class="sd">    Return a new PIL.Image.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">fill</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span> <span class="ow">or</span> <span class="n">fill</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">new_image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">polygon_mask</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">polygon</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fill</span> <span class="o">==</span> <span class="s1">&#39;background&#39;</span><span class="p">:</span>
            <span class="n">background</span> <span class="o">=</span> <span class="n">ImageStat</span><span class="o">.</span><span class="n">Stat</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">background</span><span class="o">.</span><span class="n">bands</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">background</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">background</span><span class="o">.</span><span class="n">median</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">background</span> <span class="o">=</span> <span class="n">background</span><span class="o">.</span><span class="n">median</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">background</span> <span class="o">=</span> <span class="n">fill</span>
        <span class="n">new_image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">mode</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">background</span><span class="p">)</span>
        <span class="n">new_image</span><span class="o">.</span><span class="n">paste</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
    <span class="c1"># ensure no information is lost by a adding transparency channel</span>
    <span class="c1"># initialized to fully transparent outside the polygon mask</span>
    <span class="c1"># (so consumers do not have to rely on background estimation,</span>
    <span class="c1">#  which can fail on foreground-dominated segments, or white,</span>
    <span class="c1">#  which can be inconsistent on unbinarized images):</span>
    <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;RGBA&#39;</span><span class="p">,</span> <span class="s1">&#39;LA&#39;</span><span class="p">]:</span>
        <span class="c1"># ensure transparency maximizes (i.e. parent mask AND mask):</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">ImageChops</span><span class="o">.</span><span class="n">darker</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">getchannel</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">))</span> <span class="c1"># min opaque</span>
        <span class="n">new_image</span><span class="o">.</span><span class="n">putalpha</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">transparency</span> <span class="ow">and</span> <span class="n">image</span><span class="o">.</span><span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;RGB&#39;</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">]:</span>
        <span class="c1"># introduce transparency:</span>
        <span class="n">new_image</span><span class="o">.</span><span class="n">putalpha</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_image</span></div>

<div class="viewcode-block" id="points_from_bbox"><a class="viewcode-back" href="../../api/ocrd_utils/ocrd_utils.image.html#ocrd_utils.image.points_from_bbox">[docs]</a><span class="k">def</span> <span class="nf">points_from_bbox</span><span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Construct polygon coordinates in page representation from a numeric list representing a bounding box.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%i</span><span class="s2">,</span><span class="si">%i</span><span class="s2"> </span><span class="si">%i</span><span class="s2">,</span><span class="si">%i</span><span class="s2"> </span><span class="si">%i</span><span class="s2">,</span><span class="si">%i</span><span class="s2"> </span><span class="si">%i</span><span class="s2">,</span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
        <span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">,</span> <span class="n">minx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">)</span></div>

<div class="viewcode-block" id="points_from_polygon"><a class="viewcode-back" href="../../api/ocrd_utils/ocrd_utils.image.html#ocrd_utils.image.points_from_polygon">[docs]</a><span class="k">def</span> <span class="nf">points_from_polygon</span><span class="p">(</span><span class="n">polygon</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert polygon coordinates from a numeric list representation to a page representation.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%i</span><span class="s2">,</span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">polygon</span><span class="p">)</span></div>

<div class="viewcode-block" id="points_from_xywh"><a class="viewcode-back" href="../../api/ocrd_utils/ocrd_utils.image.html#ocrd_utils.image.points_from_xywh">[docs]</a><span class="k">def</span> <span class="nf">points_from_xywh</span><span class="p">(</span><span class="n">box</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct polygon coordinates in page representation from numeric dict representing a bounding box.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">box</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="n">box</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">],</span> <span class="n">box</span><span class="p">[</span><span class="s1">&#39;w&#39;</span><span class="p">],</span> <span class="n">box</span><span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">]</span>
    <span class="c1"># tesseract uses a different region representation format</span>
    <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%i</span><span class="s2">,</span><span class="si">%i</span><span class="s2"> </span><span class="si">%i</span><span class="s2">,</span><span class="si">%i</span><span class="s2"> </span><span class="si">%i</span><span class="s2">,</span><span class="si">%i</span><span class="s2"> </span><span class="si">%i</span><span class="s2">,</span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span>
        <span class="n">x</span> <span class="o">+</span> <span class="n">w</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span>
        <span class="n">x</span> <span class="o">+</span> <span class="n">w</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">h</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">h</span>
    <span class="p">)</span></div>
<div class="viewcode-block" id="points_from_y0x0y1x1"><a class="viewcode-back" href="../../api/ocrd_utils/ocrd_utils.image.html#ocrd_utils.image.points_from_y0x0y1x1">[docs]</a><span class="k">def</span> <span class="nf">points_from_y0x0y1x1</span><span class="p">(</span><span class="n">yxyx</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct a polygon representation from a rectangle described as a list [y0, x0, y1, x1]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">y0</span> <span class="o">=</span> <span class="n">yxyx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="n">yxyx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="n">yxyx</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">yxyx</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">,</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">,</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">,</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">,</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
        <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span>
        <span class="n">x0</span><span class="p">,</span> <span class="n">y1</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="points_from_x0y0x1y1"><a class="viewcode-back" href="../../api/ocrd_utils/ocrd_utils.image.html#ocrd_utils.image.points_from_x0y0x1y1">[docs]</a><span class="k">def</span> <span class="nf">points_from_x0y0x1y1</span><span class="p">(</span><span class="n">xyxy</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct a polygon representation from a rectangle described as a list [x0, y0, x1, y1]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="n">xyxy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">y0</span> <span class="o">=</span> <span class="n">xyxy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">xyxy</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="n">xyxy</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">,</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">,</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">,</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">,</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
        <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span>
        <span class="n">x0</span><span class="p">,</span> <span class="n">y1</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="polygon_from_bbox"><a class="viewcode-back" href="../../api/ocrd_utils/ocrd_utils.image.html#ocrd_utils.image.polygon_from_bbox">[docs]</a><span class="k">def</span> <span class="nf">polygon_from_bbox</span><span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Construct polygon coordinates in numeric list representation from a numeric list representing a bounding box.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[[</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">],</span> <span class="p">[</span><span class="n">maxx</span><span class="p">,</span> <span class="n">miny</span><span class="p">],</span> <span class="p">[</span><span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">],</span> <span class="p">[</span><span class="n">minx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">]]</span></div>

<div class="viewcode-block" id="polygon_from_x0y0x1y1"><a class="viewcode-back" href="../../api/ocrd_utils/ocrd_utils.image.html#ocrd_utils.image.polygon_from_x0y0x1y1">[docs]</a><span class="k">def</span> <span class="nf">polygon_from_x0y0x1y1</span><span class="p">(</span><span class="n">x0y0x1y1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Construct polygon coordinates in numeric list representation from a string list representing a bounding box.&quot;&quot;&quot;</span>
    <span class="n">minx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x0y0x1y1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">miny</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x0y0x1y1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">maxx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x0y0x1y1</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">maxy</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x0y0x1y1</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="k">return</span> <span class="p">[[</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">],</span> <span class="p">[</span><span class="n">maxx</span><span class="p">,</span> <span class="n">miny</span><span class="p">],</span> <span class="p">[</span><span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">],</span> <span class="p">[</span><span class="n">minx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">]]</span></div>

<div class="viewcode-block" id="polygon_from_xywh"><a class="viewcode-back" href="../../api/ocrd_utils/ocrd_utils.image.html#ocrd_utils.image.polygon_from_xywh">[docs]</a><span class="k">def</span> <span class="nf">polygon_from_xywh</span><span class="p">(</span><span class="n">xywh</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Construct polygon coordinates in numeric list representation from numeric dict representing a bounding box.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">polygon_from_bbox</span><span class="p">(</span><span class="o">*</span><span class="n">bbox_from_xywh</span><span class="p">(</span><span class="n">xywh</span><span class="p">))</span></div>

<div class="viewcode-block" id="xywh_from_bbox"><a class="viewcode-back" href="../../api/ocrd_utils/ocrd_utils.image.html#ocrd_utils.image.xywh_from_bbox">[docs]</a><span class="k">def</span> <span class="nf">xywh_from_bbox</span><span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert a bounding box from a numeric list to a numeric dict representation.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">minx</span><span class="p">,</span>
        <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="n">miny</span><span class="p">,</span>
        <span class="s1">&#39;w&#39;</span><span class="p">:</span> <span class="n">maxx</span> <span class="o">-</span> <span class="n">minx</span><span class="p">,</span>
        <span class="s1">&#39;h&#39;</span><span class="p">:</span> <span class="n">maxy</span> <span class="o">-</span> <span class="n">miny</span><span class="p">,</span>
    <span class="p">}</span></div>

<div class="viewcode-block" id="xywh_from_points"><a class="viewcode-back" href="../../api/ocrd_utils/ocrd_utils.image.html#ocrd_utils.image.xywh_from_points">[docs]</a><span class="k">def</span> <span class="nf">xywh_from_points</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct a numeric dict representing a bounding box from polygon coordinates in page representation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">xywh_from_bbox</span><span class="p">(</span><span class="o">*</span><span class="n">bbox_from_points</span><span class="p">(</span><span class="n">points</span><span class="p">))</span></div>


<div class="viewcode-block" id="xywh_from_polygon"><a class="viewcode-back" href="../../api/ocrd_utils/ocrd_utils.image.html#ocrd_utils.image.xywh_from_polygon">[docs]</a><span class="k">def</span> <span class="nf">xywh_from_polygon</span><span class="p">(</span><span class="n">polygon</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Construct a numeric dict representing a bounding box from polygon coordinates in numeric list representation.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">xywh_from_bbox</span><span class="p">(</span><span class="o">*</span><span class="n">bbox_from_polygon</span><span class="p">(</span><span class="n">polygon</span><span class="p">))</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../index.html">
    <img class="logo" src="../../_static/ocrd-logo-small.png" alt="Logo"/>
    
  </a>
</p>



<p class="blurb">Software library for OCR-D</p>






<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api/ocrd/modules.html">ocrd</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/ocrd_utils/modules.html">ocrd_utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/ocrd_models/modules.html">ocrd_models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/ocrd_validators/modules.html">ocrd_validators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/ocrd_modelfactory/modules.html">ocrd_modelfactory</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/ocrd_network/modules.html">ocrd_network</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018-2023, OCR-D.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
    </div>

    

    
  </body>
</html>